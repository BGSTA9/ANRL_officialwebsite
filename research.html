<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Research — Argo Navis Research Laboratory</title>
<meta name="description"
content="Our research methodology: high-fidelity simulation, deep neural networks, and pattern discovery in number theory." />
<link rel="icon" href="assets/ANReLa.svg" type="image/svg+xml" />
<link rel="stylesheet" href="css/styles.css" />
<style>
.card__image-wrap {
  width: 100%;
  aspect-ratio: 16 / 9;
  overflow: hidden;
  margin-bottom: 1.25rem;
}
.card__image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  filter: grayscale(20%) brightness(0.95);
  transition: transform 0.4s ease, filter 0.4s ease;
}
.card:hover .card__image {
  transform: scale(1.03);
  filter: grayscale(0%) brightness(1);
}

/* shared canvas card slot */
.sim-wrap {
  width: 100%;
  aspect-ratio: 16 / 9;
  margin-bottom: 1.25rem;
  overflow: hidden;
  background: transparent;
  position: relative;
}
.sim-wrap canvas {
  width: 100%;
  height: 100%;
  display: block;
}
</style>
</head>
<body>
<main>

  <header class="page-header">
    <div class="container">
      <span class="page-header__label fade-up">Research</span>
      <h1 class="page-header__title fade-up fade-up-delay-1">Epitome of Nature</h1>
      <p class="page-header__description fade-up fade-up-delay-2">
        ANRL specializes in the development of high-fidelity system models and simulations,
        grounded in rigorous mathematical analysis. By leveraging the power of machine learning,
        the lab trains deep neural networks to enhance computational precision,
        ultimately yielding more sophisticated and accurate predictive frameworks.
      </p>
    </div>
  </header>

  <section class="section section--border-top">
    <div class="container">
      <span class="section__label fade-up">Methodology</span>
      <div class="grid grid--3">

        <!-- SIMULATION -->
        <div class="card fade-up fade-up-delay-1">
          <div class="sim-wrap">
            <canvas id="surfaceCanvas"></canvas>
          </div>
          <h3 class="card__title">SIMULATION</h3>
          <p class="card__text">ANRL architects high-precision models grounded in rigorous mathematical analysis.
            These simulations act as the laboratory for systems where traditional analytical methods reach their limits.</p>
        </div>

        <!-- NEURAL NETWORKS -->
        <div class="card fade-up fade-up-delay-2">
          <div class="sim-wrap">
            <canvas id="neuralCanvas"></canvas>
          </div>
          <h3 class="card__title">NEURAL NETWORKS</h3>
          <p class="card__text">By harvesting the adaptive power of deep learning, ANRL trains neural architectures to refine
            computational accuracy, uncovering non-linear correlations that remain invisible to classical calculation.</p>
        </div>

        <!-- GEOMETRIC INSIGHT -->
        <div class="card fade-up fade-up-delay-3">
          <div class="card__image-wrap">
            <img class="card__image"
              src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/17/Coordinate_systems_for_Laplace_equation.svg/640px-Coordinate_systems_for_Laplace_equation.svg.png"
              alt="Geometric insight into data distributions" loading="lazy" />
          </div>
          <h3 class="card__title">GEOMETRIC INSIGHT</h3>
          <p class="card__text">Our process transforms raw computational observation into mathematical truth, interrogating our
            models to decode the geometric logic hidden within complex data distributions.</p>
        </div>

      </div>
    </div>
  </section>

  <section class="section section--border-top">
    <div class="container">
      <span class="section__label fade-up">Papers</span>
      <div class="empty-state fade-up fade-up-delay-1">
        <p class="empty-state__text">Publications coming soon.</p>
      </div>
    </div>
  </section>

  <section class="section section--border-top">
    <div class="container">
      <span class="section__label fade-up">Projects</span>
      <div class="empty-state fade-up fade-up-delay-1">
        <p class="empty-state__text">Open-source projects coming soon.</p>
      </div>
    </div>
  </section>

</main>
<script src="js/components.js"></script>
<script src="js/main.js"></script>
<script>renderNav('research'); renderFooter();</script>

<!-- ═══════════════════════════════════════
     SIMULATION — chaotic 3D wave surface
═══════════════════════════════════════ -->
<script>
(function () {
  const canvas = document.getElementById('surfaceCanvas');
  const ctx    = canvas.getContext('2d');
  const wrap   = canvas.parentElement;

  let W, H;
  function resize() { W = canvas.width = wrap.clientWidth; H = canvas.height = wrap.clientHeight; }
  resize();
  new ResizeObserver(resize).observe(wrap);

  const RX = 0.50, RZ = -0.58, GRID = 40;

  const MODES = [
    { kx: 2.000, ky: 0.000, speed: 1.400, ph: 0.00 },
    { kx: 0.000, ky: 2.000, speed: 1.732, ph: 1.10 },
    { kx: 2.000, ky: 2.000, speed: 1.000, ph: 2.30 },
    { kx: 3.000, ky: 1.000, speed: 2.236, ph: 0.70 },
    { kx: 1.000, ky: 3.000, speed: 1.618, ph: 3.50 },
    { kx: 3.618, ky: 2.000, speed: 2.646, ph: 1.90 },
    { kx: 1.414, ky: 3.618, speed: 1.414, ph: 4.10 },
    { kx: 4.000, ky: 1.732, speed: 3.141, ph: 2.70 },
  ];
  const AMPS = [0.28, 0.22, 0.18, 0.14, 0.11, 0.09, 0.07, 0.05];

  function waveZ(nx, ny, t) {
    let z = 0;
    for (let i = 0; i < MODES.length; i++) {
      const { kx, ky, speed, ph } = MODES[i];
      z += AMPS[i] * Math.sin(kx * Math.PI * nx + ky * Math.PI * ny + speed * t + ph);
    }
    return z;
  }

  function project(x, y, z) {
    const x1 = x * Math.cos(RZ) - y * Math.sin(RZ);
    const y1 = x * Math.sin(RZ) + y * Math.cos(RZ);
    const y2 = y1 * Math.cos(RX) - z * Math.sin(RX);
    const z2 = y1 * Math.sin(RX) + z * Math.cos(RX);
    const sc = Math.min(W, H) * 0.43;
    return { sx: W / 2 + x1 * sc, sy: H / 2 - y2 * sc * 0.54, sz: z2 };
  }

  function draw(t) {
    ctx.clearRect(0, 0, W, H);
    const pts = [];
    for (let j = 0; j <= GRID; j++) {
      const row = [];
      for (let i = 0; i <= GRID; i++) {
        const nx = (i / GRID) * 2 - 1;
        const ny = (j / GRID) * 2 - 1;
        row.push(project(nx, ny, waveZ(nx, ny, t)));
      }
      pts.push(row);
    }
    const quads = [];
    for (let j = 0; j < GRID; j++) {
      for (let i = 0; i < GRID; i++) {
        const p00 = pts[j][i], p10 = pts[j][i+1];
        const p01 = pts[j+1][i], p11 = pts[j+1][i+1];
        const sz = (p00.sz + p10.sz + p01.sz + p11.sz) / 4;
        quads.push({ p00, p10, p01, p11, sz });
      }
    }
    quads.sort((a, b) => a.sz - b.sz);
    quads.forEach(({ p00, p10, p01, p11, sz }) => {
      const depth = Math.max(0, Math.min(1, (sz + 0.6) / 1.15));
      ctx.beginPath();
      ctx.moveTo(p00.sx, p00.sy);
      ctx.lineTo(p10.sx, p10.sy);
      ctx.lineTo(p11.sx, p11.sy);
      ctx.lineTo(p01.sx, p01.sy);
      ctx.closePath();
      ctx.fillStyle = `rgba(255,255,255,${depth * 0.08})`;
      ctx.fill();
      ctx.strokeStyle = `rgba(255,255,255,${0.18 + depth * 0.55})`;
      ctx.lineWidth = 0.55;
      ctx.stroke();
    });
  }

  let t0 = null;
  function frame(now) {
    if (!t0) t0 = now;
    draw((now - t0) / 1000);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>

<!-- ═══════════════════════════════════════
     NEURAL NETWORKS — particle orb
═══════════════════════════════════════ -->
<script>
(function () {
  const canvas = document.getElementById('neuralCanvas');
  const ctx    = canvas.getContext('2d');
  const wrap   = canvas.parentElement;

  let W, H, CX, CY, R;
  function resize() {
    W = canvas.width  = wrap.clientWidth;
    H = canvas.height = wrap.clientHeight;
    CX = W / 2; CY = H / 2;
    R  = Math.min(W, H) * 0.19;   /* orb radius */
  }
  resize();
  new ResizeObserver(resize).observe(wrap);

  /* ── Particles ── */
  const N_ORB    = 220;   /* on the ring */
  const N_TENDRILS = 55;  /* long filaments */
  const N_SCATTER  = 80;  /* loose background sparks */

  /* Ring particles — sit on / near the glowing circle */
  const orbPts = Array.from({ length: N_ORB }, (_, i) => {
    const baseAngle = (i / N_ORB) * Math.PI * 2;
    const jitter    = (Math.random() - 0.5) * 0.55;   /* angular scatter */
    const rJitter   = (Math.random() - 0.5) * 0.28;   /* radial scatter */
    return {
      baseAngle,
      angle:  baseAngle + jitter,
      rFrac:  1 + rJitter,          /* 1 = on ring, <1 inside, >1 outside */
      speed:  (Math.random() - 0.5) * 0.28,
      size:   0.6 + Math.random() * 1.4,
      alpha:  0.5 + Math.random() * 0.5,
    };
  });

  /* Tendril particles — long curling filaments that radiate outward */
  const tendrils = Array.from({ length: N_TENDRILS }, () => {
    const startAngle = Math.random() * Math.PI * 2;
    const len        = 0.55 + Math.random() * 1.3;   /* length as multiple of R */
    const curl       = (Math.random() - 0.5) * 2.8;  /* how much it curves */
    const segs       = 18 + Math.floor(Math.random() * 22);
    return { startAngle, len, curl, segs, speed: (Math.random() - 0.5) * 0.12 };
  });

  /* Scatter sparks */
  const sparks = Array.from({ length: N_SCATTER }, () => {
    const angle = Math.random() * Math.PI * 2;
    const dist  = R * (0.3 + Math.random() * 2.4);
    return {
      x:     CX + Math.cos(angle) * dist,
      y:     CY + Math.sin(angle) * dist,
      size:  0.4 + Math.random() * 1.1,
      alpha: 0.1 + Math.random() * 0.35,
      drift: { x: (Math.random() - 0.5) * 0.25, y: (Math.random() - 0.5) * 0.25 },
    };
  });

  function draw(t) {
    ctx.clearRect(0, 0, W, H);

    const cx = W / 2, cy = H / 2;
    const r  = Math.min(W, H) * 0.19;

    /* ── Glow core ── */
    const grd = ctx.createRadialGradient(cx, cy, r * 0.2, cx, cy, r * 1.05);
    grd.addColorStop(0,   'rgba(255,255,255,0.22)');
    grd.addColorStop(0.45,'rgba(255,255,255,0.10)');
    grd.addColorStop(1,   'rgba(255,255,255,0.00)');
    ctx.beginPath();
    ctx.arc(cx, cy, r * 1.05, 0, Math.PI * 2);
    ctx.fillStyle = grd;
    ctx.fill();

    /* ── Tendrils ── */
    tendrils.forEach(td => {
      const angle0 = td.startAngle + td.speed * t;
      ctx.beginPath();
      for (let s = 0; s <= td.segs; s++) {
        const frac   = s / td.segs;
        const curAngle = angle0 + td.curl * frac * 0.6;
        const dist   = r * (1 + frac * td.len);
        const px     = cx + Math.cos(curAngle) * dist;
        const py     = cy + Math.sin(curAngle) * dist;
        const wiggle = Math.sin(frac * 7 + t * 1.8 + td.startAngle) * r * 0.06;
        const perpX  = -Math.sin(curAngle) * wiggle;
        const perpY  =  Math.cos(curAngle) * wiggle;
        s === 0 ? ctx.moveTo(px + perpX, py + perpY)
                : ctx.lineTo(px + perpX, py + perpY);
      }
      const alpha = 0.08 + 0.12 * Math.abs(Math.sin(td.startAngle + t * 0.3));
      ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
      ctx.lineWidth   = 0.5 + Math.random() * 0.4;
      ctx.stroke();
    });

    /* ── Ring particles ── */
    orbPts.forEach(p => {
      const a  = p.angle + p.speed * t * 0.18;
      const rr = r * p.rFrac;
      const px = cx + Math.cos(a) * rr;
      const py = cy + Math.sin(a) * rr;
      /* proximity to ring edge → brighter */
      const glow = ctx.createRadialGradient(px, py, 0, px, py, p.size * 2.5);
      glow.addColorStop(0, `rgba(255,255,255,${p.alpha})`);
      glow.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.beginPath();
      ctx.arc(px, py, p.size * 2.5, 0, Math.PI * 2);
      ctx.fillStyle = glow;
      ctx.fill();
    });

    /* ── Scatter sparks (slowly drift) ── */
    sparks.forEach(sp => {
      sp.x += sp.drift.x;
      sp.y += sp.drift.y;
      /* soft wrap */
      if (sp.x < 0) sp.x = W; if (sp.x > W) sp.x = 0;
      if (sp.y < 0) sp.y = H; if (sp.y > H) sp.y = 0;
      ctx.beginPath();
      ctx.arc(sp.x, sp.y, sp.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${sp.alpha})`;
      ctx.fill();
    });

    /* ── Hard ring edge ── */
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255,255,255,0.55)';
    ctx.lineWidth   = 1.2;
    ctx.stroke();

    /* ── Inner cluster density ── */
    for (let k = 0; k < 6; k++) {
      const ka = (k / 6) * Math.PI * 2 + t * 0.08;
      const kr = r * (0.2 + 0.5 * Math.random());
      const kx = cx + Math.cos(ka) * kr * 0.7;
      const ky = cy + Math.sin(ka) * kr * 0.55;
      const kg = ctx.createRadialGradient(kx, ky, 0, kx, ky, r * 0.22);
      kg.addColorStop(0, 'rgba(255,255,255,0.12)');
      kg.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.beginPath();
      ctx.arc(kx, ky, r * 0.22, 0, Math.PI * 2);
      ctx.fillStyle = kg;
      ctx.fill();
    }
  }

  let t0 = null;
  function frame(now) {
    if (!t0) t0 = now;
    draw((now - t0) / 1000);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>